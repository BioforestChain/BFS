const g=typeof require<"u"?require("electron"):function(){return console.error('If you need to use "electron" in the Renderer process, make sure that "nodeIntegration" is enabled in the Main process.'),{}}();let w;if(typeof document>"u"){w={};const e=["invoke","postMessage","send","sendSync","sendTo","sendToHost","addListener","emit","eventNames","getMaxListeners","listenerCount","listeners","off","on","once","prependListener","prependOnceListener","rawListeners","removeAllListeners","removeListener","setMaxListeners"];for(const t of e)w[t]=()=>{throw new Error(`ipcRenderer doesn't work in a Web Worker.
You can see https://github.com/electron-vite/vite-plugin-electron/issues/69`)}}else w=g.ipcRenderer;g.clipboard;g.contextBridge;g.crashReporter;const G=w;g.nativeImage;g.shell;g.webFrame;g.deprecate;const S=e=>(A(e,"addEventListener",1),A(e,"removeEventListener",1),Y(e),e),A=(e,t,n)=>{const s=e[t];return e[t]=function(...r){return r[n]=T(r[n]),s.apply(this,r)},e},R=new WeakMap,T=e=>{if(typeof e=="object")return e.handleEvent=T(e.handleEvent),e;let t=R.get(e);return t===void 0&&(t=function(n){return JSON.stringify(n.data,function(r,a){return Array.isArray(a)&&a[0]==="#PORT#"?(this[r]=n.ports[a[1]],null):a}),e.call(this,n)},R.set(e,t),R.set(t,e)),t},Y=e=>{const t=e.postMessage;return e.postMessage=function(n,s){Array.isArray(s)?(JSON.stringify(n,function(a,o){if(o&&typeof o=="object"&&"postMessage"in o){const i=s.indexOf(o);if(i!==-1)return this[a]=["#PORT#",i],null}return o}),t.call(this,n,s)):s?t.call(this,n,s):t.call(this,n)},e};/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const C=Symbol("Comlink.proxy"),J=Symbol("Comlink.endpoint"),B=Symbol("Comlink.releaseProxy"),x=Symbol("Comlink.finalizer"),E=Symbol("Comlink.thrown"),N=e=>typeof e=="object"&&e!==null||typeof e=="function",X={canHandle:e=>N(e)&&e[C],serialize(e){const{port1:t,port2:n}=new MessageChannel;return P(e,t),[n,[n]]},deserialize(e){return e.start(),I(e)}},$={canHandle:e=>N(e)&&E in e,serialize({value:e}){let t;return e instanceof Error?t={isError:!0,value:{message:e.message,name:e.name,stack:e.stack}}:t={isError:!1,value:e},[t,[]]},deserialize(e){throw e.isError?Object.assign(new Error(e.value.message),e.value):e.value}},_=new Map([["proxy",X],["throw",$]]);function K(e,t){for(const n of e)if(t===n||n==="*"||n instanceof RegExp&&n.test(t))return!0;return!1}function P(e,t=globalThis,n=["*"]){t.addEventListener("message",function s(r){if(!r||!r.data)return;if(!K(n,r.origin)){console.warn(`Invalid origin '${r.origin}' for comlink proxy`);return}const{id:a,type:o,path:i}=Object.assign({path:[]},r.data),f=(r.data.argumentList||[]).map(p);let c;try{const u=i.slice(0,-1).reduce((l,m)=>l[m],e),d=i.reduce((l,m)=>l[m],e);switch(o){case"GET":c=d;break;case"SET":u[i.slice(-1)[0]]=p(r.data.value),c=!0;break;case"APPLY":c=d.apply(u,f);break;case"CONSTRUCT":{const l=new d(...f);c=re(l)}break;case"ENDPOINT":{const{port1:l,port2:m}=new MessageChannel;P(e,m),c=ne(l,[l])}break;case"RELEASE":c=void 0;break;default:return}}catch(u){c={value:u,[E]:0}}Promise.resolve(c).catch(u=>({value:u,[E]:0})).then(u=>{const[d,l]=L(u);t.postMessage(Object.assign(Object.assign({},d),{id:a}),l),o==="RELEASE"&&(t.removeEventListener("message",s),z(t),x in e&&typeof e[x]=="function"&&e[x]())}).catch(u=>{const[d,l]=L({value:new TypeError("Unserializable return value"),[E]:0});t.postMessage(Object.assign(Object.assign({},d),{id:a}),l)})}),t.start&&t.start()}function Q(e){return e.constructor.name==="MessagePort"}function z(e){Q(e)&&e.close()}function I(e,t){return k(e,[],t)}function h(e){if(e)throw new Error("Proxy has been released and is not useable")}function W(e){return y(e,{type:"RELEASE"}).then(()=>{z(e)})}const b=new WeakMap,M="FinalizationRegistry"in globalThis&&new FinalizationRegistry(e=>{const t=(b.get(e)||0)-1;b.set(e,t),t===0&&W(e)});function Z(e,t){const n=(b.get(t)||0)+1;b.set(t,n),M&&M.register(e,t,e)}function ee(e){M&&M.unregister(e)}function k(e,t=[],n=function(){}){let s=!1;const r=new Proxy(n,{get(a,o){if(h(s),o===B)return()=>{ee(r),W(e),s=!0};if(o==="then"){if(t.length===0)return{then:()=>r};const i=y(e,{type:"GET",path:t.map(f=>f.toString())}).then(p);return i.then.bind(i)}return k(e,[...t,o])},set(a,o,i){h(s);const[f,c]=L(i);return y(e,{type:"SET",path:[...t,o].map(u=>u.toString()),value:f},c).then(p)},apply(a,o,i){h(s);const f=t[t.length-1];if(f===J)return y(e,{type:"ENDPOINT"}).then(p);if(f==="bind")return k(e,t.slice(0,-1));const[c,u]=O(i);return y(e,{type:"APPLY",path:t.map(d=>d.toString()),argumentList:c},u).then(p)},construct(a,o){h(s);const[i,f]=O(o);return y(e,{type:"CONSTRUCT",path:t.map(c=>c.toString()),argumentList:i},f).then(p)}});return Z(r,e),r}function te(e){return Array.prototype.concat.apply([],e)}function O(e){const t=e.map(L);return[t.map(n=>n[0]),te(t.map(n=>n[1]))]}const H=new WeakMap;function ne(e,t){return H.set(e,t),e}function re(e){return Object.assign(e,{[C]:!0})}function L(e){for(const[t,n]of _)if(n.canHandle(e)){const[s,r]=n.serialize(e);return[{type:"HANDLER",name:t,value:s},r]}return[{type:"RAW",value:e},H.get(e)||[]]}function p(e){switch(e.type){case"HANDLER":return _.get(e.name).deserialize(e.value);case"RAW":return e.value}}function y(e,t,n){return new Promise(s=>{const r=se();e.addEventListener("message",function a(o){!o.data||!o.data.id||o.data.id!==r||(e.removeEventListener("message",a),s(o.data))}),e.start&&e.start(),e.postMessage(Object.assign({id:r},t),n)})}function se(){return new Array(4).fill(0).map(()=>Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16)).join("-")}const oe=e=>{let t=!1,n;return(...s)=>(t===!1&&(t=!0,n=e(...s)),n)},j=new MessageChannel,V=new MessageChannel,F=j.port1,v=V.port1;G.postMessage("renderPort",{},[j.port2,V.port2]);S(F);S(v);const D=F;let U={};const q=()=>{P(U,D)};Object.assign(globalThis,{mainPort:D,start:q});const ae=oe(e=>{U=e,q()}),ie=I(v);export{ae as exportApis,ie as mainApis,D as mainPort};
