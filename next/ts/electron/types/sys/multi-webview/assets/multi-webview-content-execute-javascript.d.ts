declare const _default: "\n(() => {\n  console.log('--------')\n  // if (!globalThis.__native_close_watcher_kit__) {\n  //   globalThis.__native_close_watcher_kit__ =  {\n  //     allc: 0,\n  //     _watchers: new Map(),\n  //     _tasks: new Map(),\n  //     registryToken: function(consumeToken){\n  //       if (consumeToken === null || consumeToken === \"\") {\n  //         throw new Error(\"CloseWatcher.registryToken invalid arguments\");\n  //       }\n  //       const resolve = this._tasks.get(consumeToken)\n  //       if(resolve === undefined) throw new Error('resolve === undefined');\n  //       const id = this.allc++;\n  //       resolve(id + \"\");\n  //     },\n  //     tryClose: function(id){\n  //       const watcher = this._watchers.get(id);\n  //       if(watcher === undefined) throw new Error('watcher === undefined');\n  //       watcher.dispatchEvent(new Event(\"close\"))\n  //     }\n  //   };\n\n  //   // 这里会修改了 window.open 的方法 是否有问题了？？\n  //   globalThis.open = function(arg){\n  //     console.error('open 方法被修改了 需要调用 主渲染进程的 openWebview 方法，但是还没有处理', arg)\n  //   }\n  // }\n\n  // console.log('window: ', window)\n\n  globalThis.fetch = () => {\n    console.log(\">>>>>>>>>>>>\")\n  } \n  \n  // // 拦截 fetch\n  // globalThis.nativeFetch = globalThis.fetch;\n  // globalThis.fetch = (request) => {\n  //   let url = typeof request === 'string' ? request : request.url;\n  //   if(url.endsWith('bfs-metadata.json')){\n  //     // 把请求发送出去\n  //     console.log('需要拦截的请求', request)\n  //     console.log('window.navigator.userAgent', window.navigator.userAgent);\n  //     // 把请求发送给 jsMM 模块\n  //     url = 'http://api.browser.sys.dweb-443.localhost:22605/open_download?url=' + url\n  //     // 只能够想办法 发送给 browser 让 browser 处理\n  //     return globalThis.nativeFetch(url)\n  //   }else if(\n  //     request.method == \"GET\" && request.url.host?.endsWith(\".dweb\")  && (request.url.scheme == \"http\" || request.url.scheme == \"https\")\n  //   ){\n  //     console.log('locstion', location)\n  //   }else{\n  //     return globalThis.nativeFetch(request)\n  //   }\n  // }\n\n  // core \n  function inputBindVirtualKeyboard(el){\n    el.removeEventListener('focusin',bindVirtualKeyboardFocusin)\n    el.removeEventListener('focusout',bindVirtualKeyboardFocusout)\n    el.addEventListener('focusin', bindVirtualKeyboardFocusin)\n    el.addEventListener('focusout',bindVirtualKeyboardFocusout)\n    console.log('bind virtual keyboard')\n  }\n\n  function bindVirtualKeyboardFocusin(){\n    window.electron.ipcRenderer.sendToHost('virtual_keyboard_open')\n  }\n\n  function bindVirtualKeyboardFocusout(){\n    window.electron.ipcRenderer.sendToHost('virtual_keyboard_close')\n  }\n\n  function inputIsNeedBindVirtualKeyboard(node){\n    return node.tagName === \"INPUT\"\n    && (\n      node.type === \"email\"\n      || node.type === \"number\"\n      || node.type === \"password\"\n      || node.type === \"search\"\n      || node.type === \"tel\"\n      || node.type === \"text\"\n      || node.type === \"url\"\n    ) \n  }\n\n  function callback(mutationList, observe){\n    mutationList.forEach(mutationRecord => {\n      switch(mutationRecord.type){\n        case \"childList\":\n          mutationRecord.addedNodes.forEach(node => {\n            // 添加了节点可能只有直接的子节点在这里，嵌套的子节点不再这里哦\n            if(node.nodeType !== Node.ELEMENT_NODE) return;\n            const allEl = getSub(node)\n            allEl.forEach(el => {\n              if(el.shadowRoot){\n                // 添加 监听\n                createMutationObserver(el.shadowRoot, callback)\n                return;\n              }\n              // 绑定 virtual-keyboard\n              inputIsNeedBindVirtualKeyboard(el)? inputBindVirtualKeyboard(el) : \"\";\n            })\n          })\n\n          mutationRecord.removedNodes.forEach(node => {\n            // 移除监听\n            if(node.shadowRoot){\n              node.shadowRoot.removeObserver();\n            }\n          })\n        break;\n      }\n    })\n  }\n\n  function getSub(root){\n    const sub = Array.from(root.children).reduce((pre, el) => {\n      getSub(el)\n      return [...pre, ...getSub(el)]\n    },[])\n    if(root.shadowRoot){\n      return [...root.shadowRoot.children, ...sub]\n    } \n    return [...root.children, ...sub]\n  }\n\n  function createMutationObserver(el, callback){\n    const observerOptions = {\n      childList: true,  // 观察目标子节点的变化，是否有添加或者删除\n      subtree: true     // 观察后代节点，默认为 false\n    }\n    let observer = new MutationObserver(callback);\n    observer.observe(el, observerOptions);\n    console.error('observer 在什么时候会被回收')\n    el.removeObserver = () => {\n      console.log('回收了')\n      observer = null\n    }\n  }\n\n  createMutationObserver(document.body, callback)\n  const allEl = getSub(document.body)\n  allEl.forEach(el => {\n    if(el.shadowRoot){\n      createMutationObserver(el.shadowRoot, callback)\n      console.log('添加了 observe')\n      return;\n    }\n    inputIsNeedBindVirtualKeyboard(el)? inputBindVirtualKeyboard(el) : \"\";\n  })\n})()\n";
export default _default;
