# Common(原 Android)

1. ✨ window.std.dweb 实现三层解构
   1. 内容层：包含 Window、Top-Window、Picture-In-Picture 等内容
      > 目前我们主要使用窗口渲染适配器来实现这一部分内容，这点中期内不会改变
      > 未来如果有窗口共享，就是来自网络的窗口，比如窗口流转，那么这个代码仍然可以复用，需要在原机器上渲染这个图层的内容，然后通过局域网络传输这个图层，就像 WebRTC 一样。
      > 目前内容层只提供了“窗口内容渲染”的标准，这在很长一段时间内不会发生改变，对于应用来说，它只直到自己的视图被渲染在某一个物理宽高并且有特定缩放比例的矩形
      1. ✨ 窗口内容会实现“图层管理”功能（和现在的 mwebview 类似）
         > “图层管理”除了包含 zyzwh 的属性之外，还会提供基本的 transfrom，从而开发者可以基于这个实现传统应用的路由跳转的动画。
   1. 模态层：通常包含 Bottom-Sheet、Dialog、Side-Sheet
      1. 模态层不像内容层，是可以并发渲染多个内容的，模态层是单发的模式，基于先进先出原则，同一时间只会有一个模态窗口出现，应用每次只能申请一次模态层的渲染权限（和 wid 类似的一个句柄），只有当前模态框被关闭后，才能重新申请。所以鼓励应用尽可能在一个模态框中将需要的交互全部完成
      1. 注意，要理解这里使用“通常”这个词汇，是因为模态层是类似 Window 的一个视图，它也包含了边框：其包含所属应用的基本信息和一些基本的控制按钮。因此它并不局限于上诉的视图形式，所以你可以在这个渲染层中自己去渲染多个 Bottom-Sheet 视图、多个 Dialog 都没关系，而和 Window 最大的区别是，此时你是无法注册返回按钮的。
         > 注意，模态层在实现的时候，一定会避免被伪造，因为它通常出现在跨应用交互之间
      1. 对于模态层的定义就是要强制用户进行交互，而反过来，用户当然可以强制关闭的模态层，因为我们在多个平台上统一了返回按钮的行为，所以模态层只会有两种配置：一种可以一次返回就关闭模态层，一种需要用户两次返回来关闭模态层
      1. 但是前期，我们只会提供 Bottom-Sheet、Dialog 的标准渲染接口，给到 jmm 应用的接口也是如此。未来可能随着开发者的需求增加，我们才会提供一些比较复杂的渲染组件
   1. 通知层：专门用于绘制 notification、toast、notification-drawer 等
      > toast 和 notification 不是用原生的 toast，因为需要显示应用图标和 mmid，但如果用户离开了 dweb-browser 应用程序，那么会使用 notification.sys.dweb 来告知用户后台情况。和聊天应用的图标类似，我们会将应用的 icon、shortname、mmid 显示出来，并将相应的信息显示出来
      1. toast 的作用是程序在后台时（没有 win 或者 win 被最小化），需要像用户提供一些进度的信息时，那么就可以使用 toast 来显示一些信息，这时候会使用 taskbar 来显示 toast：taskbar 会将应用的图标显示出来，并用水平 tooltip 的形式来显示 toast-text。它没有 action，但是它挂在 app-icon 旁边，所以用户可以点击 app-icon 将应用窗口恢复。
         > 注意，即便有 app 在最大化的模式下，这时候 taskbar 默认只显示当前 app 的 icon。此时如果有 toast，那么对应的 app-icon 还是会动画地显示出来。
      1. notification 一般显示在 window 顶部，如果可以显示在顶部窗口栏上方，如果不行，显示在顶部窗口栏的下方，它可以包含一个 action（使用提供图标（ImageResource）或者文本作为 Action 的内容）。
         1. notification 本身可以包含一个 url，如果有 url，那么会显示一个拖拽栏，用户可以拖拽展开这个 notification.url：将激活成窗口。用 tap 可以达成一样的目的。
         1. notification.action 提供了另外的 url，比如可以用于复制文本，或者打开另外的窗口
         1. 上滑、左滑、右滑都会关闭它
            > 未来可能会开放额外的接口，来实现自定义配置
1. IpcMessage 使用 producer-consumer（生产者消费者模式）替代 pub-sub（Signal）
1. 新的设计
1. Others
   - DwebView Open Deeplink Dialog
1. 【提案】控制窗口内容的渲染方向（横屏、竖屏）

   1. 首先要考虑在桌面端上，它本来就是天然的横屏模式；在传统手持设备上，它的天然是竖屏；在平板设备上，更多是横屏模式少数是竖屏；在折叠屏设备上，更多是竖屏模式少数是近正方形模式；
   1. 其次还有一个点：关于屏幕的方向，用户拥有第一话语权，其次才是应用拥有建议权
   1. 另外，因为多窗口模式的存在，我们不能只针对一个窗口进行旋转，虽然理论上可行，但细想就很难实现：我们需要对触摸的位置进行转换，而 webview 属于系统视图，这通常做不到；还有输入框与软键盘的配合也会出问题。因此需验证必须是一整个屏幕方向都统一进行旋转，而不是特指某一个窗口
   1. 一旦屏幕方向进行了旋转，那么窗口的位置与大小根据以下算法优先级进行：
      1. 保障窗口的内容大小：如果在新的屏幕大小下，内容如果受到了挤压，那么判断如果可以进行宽高交换后可以不受挤压或者说减少挤压，那么进行换高互换（挤压会发生，一个很重要的原因是窗口的存在边框）。
      1. 保障窗口的内容比例：不论宽高交换与否，如果内容受到了挤压（面积缩小），那么我们尽量保持内容比例不变的基础上去渲染窗口
      1. 保障窗口的位置：使用原窗口的重心（一般就是中心）所在 x/y 轴线的比例进行转换，这首先需要知道转换后的窗口外边框大小，然后计算它与整个屏幕的大小差值，在基于这个差值与坐标比例进行相乘，得出的就是新坐标的位置
   1. desktop 与 taskbar 同样需要做自适应设计
      1. 其中 desktop 最好是做“瓷砖设计”：
         1. 以 6✖️6 作为一个基本瓷砖单元来摆放图标与组件
         1. 那么在窗口旋转的时候，多个瓷砖使用流式布局来进行自适应摆放，瓷砖内的内容因为是正方形，所以旋转即可继续使用
         1. 瓷砖内的内容虽然可以旋转，但是瓷砖的位置可以是固定的，如地图一样，因此屏幕旋转后，滚动的方向保持不变（滚动时可以显示 minimap 来引导用户所在位置）
      1. taskbar 作为一个应用抽屉，做好单向滚动与展开就行
         1. taskbar 在默认情况下是一个一维的竖向，因此屏幕方向发生改变的时候， 只需要缩短伸长这一维的滚轴即可
         1. 如果未来 taskbar 需要承载很多应用切换，可以考虑“拟物化设计”：
            1. 设计成类似 picker 的滚轴
            1. 提供一个选中指示器
            1. 用户可以通过滚动来快速切换当前要聚焦的应用
         1. 可以考虑提供一个快速的 resort-toggle 按钮？打开这个按钮，然后依次选中应用图标，这时候应用并不会被聚焦，而是图标会被排序到最前方，这是否可以缓解滚轴缩短导致不易寻找切换应用的问题？
   1. 如果窗口在最大化模式下，在窗口 menuPanel 提供“切换设备屏幕方向”的按钮，默认情况下，该项是“Auto/自动”，意味着跟随系统。
      1. 在折叠设备中，可能会有更加丰富的选项来堆砌进行适配
      1. 目前这个功能值在窗口最大化模式或全屏模式下提供，此时用户可以用这个按钮强制进行方向旋转
      1. Android 中只要声明了可旋转，那么即便方向锁定，但屏幕发生了旋转，那么系统会给出一个小按钮来告知用户可以进行旋转，那时候也可以可以进行强制旋转，不过属于操作系统性质的功能
   1. 最后关于该提案具体的 API，这里给出两种方案，其对应的接口设计和功能设计如下：

      1. 方案一 prefersWindowAspectRatio 提供窗口比例偏好
         1. 新增 `file://window.std.dweb/prefersWindowAspectRatio?ratio=W1:H1,W2:H2...`
            1. 基本的格式是`{width-weight}*{height-weight}`
            1. 多个声明使用`,`进行分隔
            1. `width-weight/height-weight` 的的格式是：`+float && > 0`
         1. 在 manifest 中新增属性：`prefersWindowAspectRatio:List<width:Float,height:Float>`
         1. 在浮动模式下，我们默认选择对当前屏幕的比例最接近的一个比例来展示窗口
      1. 方案二 prefersWindowSize 提供窗口大小偏好
         1. 新增 `file://window.std.dweb/prefersWindowSize?size=W1*H1,W2~W2*H2,>=W3*<H3...`
            1. 基本的格式是`{width-size}*{height-size}`
            1. 多个声明使用`,`进行分隔
            1. `width-size/height-size` 的的格式是：
               1. `dp = +float` 正数，缺省了`dp`这个单位
               1. `percent = +float%` 正数，不可大于 100%，缺省了`vw/vh`单位
               1. `with_unit = +float 'dp'|'vw'|'vh'|'vmin'|'vmax'` 可以携带三种单位：`dp` 是指物理像素；`vw` 为百分比屏幕宽度，`vh` 为百分比屏幕高度，参考 css
               1. `base_size = dp | percent | with_unit` 最终都会计算成 `dp`
               1. `min_size = 'min(' base_size[, base_size[, base_size...]] ')'`
                  1. min 函数挑选出多个值中最小的 `dp` 值
                  1. min 函数一定会注入一个 `maxViewWidth/maxViewHeight` 值，也就是说怎么都不会超出这个值。一般来说就是屏幕宽高
               1. `max_size = 'max(' base_size[, base_size[, base_size...]] ')'`
                  1. max 函数挑选出多个值中最小的 `dp` 值
                  1. max 函数一定会注入一个 `minViewWidth/minViewHeight` 值，也就是说怎么都不会小于这个值。一般来说就是屏幕宽高的 20%
               1. `size = base_size | min_size | max_size` 代表一个可以算出来的精确值
               1. `between_range = size '~' size` 代表一个范围，要求两个 size 前者必须要小于等于后者
               1. `min_range = size '~' `代表最小值到`maxViewWidth/maxViewHeight`的范围
               1. `max_range = '~' size `代表`minViewWidth/minViewHeight`到最大值的范围
               1. `range = min_range | max_range | between_range`
               1. `width-size/height-size = range|size`最终，宽高的定义，可以是一个具体的值也可以是一个范围
            1. 如果格式解析出错，那么不会发生异常，那么只会提供警告，然后剔除掉这项错误格式的配置项
            1. 默认情况下 prefersWindowSize 的值为`0~*0~`，意味着可以进行完全自由的适配
            1. 如果用户自己设置的 prefersWindowSize 最终解析下来，没有任何合法的项，那么会缺省使用`0~*0~`
            1. 虽然可以配置成`0dp`，但是渲染层会有自己的 WindowLimits 设置，它会将窗口的最小值锁定成：`min(80dp, 20%) * min(80dp, 20%)`
         1. 在 manifest 中新增属性：`prefersWindowSize:List<width:String,height:String>`
         1. 在窗口的 menuPanel 中提供“切换窗口尺寸”的按钮，用户可以强制选择自己要的窗口视图，默认情况下，该项是“Auto/自动”，意味着根据算法自动进行匹配（参考深色模式切换功能）
            1. 该算法，基于当前的窗口大小，在配置数组中依次进行寻找，并计算出对应的 scale 值，直到 scale 为 1
            1. 如果没有 scale 为 1，那么使用 scale 最大且稳定排序靠前的项
         1. prefersWindowSize 会自动匹配现有的设备分辨率和方向，自动选择匹配度最高的那个。但要注意，这并不意味着窗口的大小一定会跟着 prefersWindowSize 的设置去走，prefersWindowSize 只是一个参考值，具体窗口的大小，用户是拥有完全的控制权的（在未来的 VR 设备上更是如此）。因此如果有需要，开发需要自己去适配 prefersWindowSize 情况之外大小。
            > 比方说，开发者可以将自己的内容锁定成 600✖️400 的大小，但是窗口给了 600\*450 的大小，那么开发者可以自己将那多出来的 50dp 的高度进行黑边处理
         1. 浮动模式是比较特殊的，它自带 scale 算法：
            > 目前，我们对浮动窗口简单粗暴地进行了初始化，但如果要实现这个提案，我们最好需要对窗口的大小和位置进行记忆
            1. 浮动模式下，我们
         1. 如果在当前设备屏幕方向下，没有完美的匹配度，那么可能会发生的事情 scale 属性值过小，比如在竖屏模式下显示横屏窗口，那么此时窗口会自动识别设备是否可以修改设备屏幕方向。如果可以，那么 menu 按钮上会浮动出啊一个 tooltip，显示“切换设备屏幕方向”按钮，用户可以快速点击它来实现屏幕方向的切换，这样可以省去打开 menu 面板的步骤。

      > 使用比例的方案可以给内核开发者更多的适配方案，对于开发者来时心智成本比较低，不过可能需要配合 minWidth/minHeight 来做一些限制
      > 使用大小的方案理论上可以很精确地控制窗口，但这内核开发者与用户来说，可能会与应用开发者的意图发生冲突

1. ♻️ desk.browser.sys
   1. ♻️ desktop.vue、taskbar.vue 使用 Compose 替代实现
   1. ♻️ 重构窗口的启动流程，Application 被启动的时候，窗口会被直接打开渲染（未来会显示一个简易的 TUI 作为默认视图，目前没有，就用启动页），也就是说窗口的激活行为不再属于 plaoc 来管理，而是由 desk 自己内置。那么相应的，程序需要向 desk 模块领取自己的 wid（窗口句柄），然后再将这个句柄发给 mwebview，让它使用这个句柄进行渲染注册。
   1. ✨ 动效强化，所有的用户行为都应该有动画来对用户之后的操作形成直觉
      1. ✨ 应用打开时，需要从 taskbar 中飞出窗口
         > 注意不是从 desktop 中飞出，一方面我们希望用户接下来的交互都是围绕 taskbar 来展开应用交互；
         > 另一方面，desktop 未来可能会慢慢进化成一个瀑布流的桌面组件集，我们的目的时让每个应用的最基本的工作都可以在 desktop 上，只有专业工作或者说完整的工作才需要到应用内部进行使用。也就是说 desktop 会慢慢进化成一个大地图，用户像在游戏中的传送门一样快速地找到自己想要的新功能。在这种形态下，地图上大部分是通过算法固定算出来，也就是说在每台设备上都一样；同时会给用户可定制化的个人空间，用来做个性化地传送门功能
         > 同时 taskbar 会进化成应用抽屉、应用收纳，所有的应用都可以在这里快速找到入口。虽然 taskbar 不想 desktop 一样哟那么大的空间可以做一个大地图，但是 taskbar 仍然可以做一个“颜色地图”，它可以一维化，也可以二维三维，灵活性更高，因为相比于文字可能存在国际化问题、多音、等多种排序标准导致的困惑行，颜色对于人类来来说有着更加统一的效果。具体点说，可以想象一下有人使用很多张照片拼出一张的照片的效果，一张照片虽然颜色很多，但颜色能通过信息丢失进行像素化，随意还是可以简化成一个颜色。
      1. ✨ 应用最小化时，需要将它动画收入到 taskbar 中
      1. ✨ 点击“切换桌面”时，所有窗口收入切换按钮中，按钮层叠显示窗口的数量（不超过 4 个，注意这不是固定的图标，而是动态计算出来的圆角矩形，只是显示上不超过 4 个而已），其中每一个窗口恢复时，动画逆放（也就是说即便是通过点击 taskbar 的图标，它的逆放也是从切换按钮中来的。）
   1. ✨ 打开一个新的窗口，类似 app 双开？
   1. ✨ 新增桌面小组件功能，将 taskbar 移植到桌面组件上
      > 需要管理节目来管理摆放的顺序
1. 🎉✨ mwebview.browser.sys = window.std.dweb + webview.sys.dweb
   1. 🎉 新增 webview.sys.dweb 模块
      > 它目前还算不上 std，因为 std 需要更加强大更加统一的的接口，比如各种请求拦截。而目前各个平台提供的接口都不一样，我们做不到统一，所以只能下方到 sys 这个级别，来做差异化的接口设计。
      > 在未来的计划中，webview.std.dweb 可能会被设计出来，但它一定也是基于 webview.sys.dweb 来实现的。webview.std.dweb 的实现原理之前有在群里头发过，基本上，就是用 js 拦截托管所有 html、css、js，只是把 webview.sys 作为一个开箱即用的 super-canvas 来使用而已。
   1. ♻️ 未来 mwebview 会被解构，利用 window.std.dweb 的图层管理功能实现所谓的多视图，其中 webview.sys.dweb 就专注于单视图的渲染。
1. 🎉 download.std.dweb
   1. 实现下载管理页面 DownloadController.Render
   1. 每一个下载项目至少包括以下基本信息：编号、链接、文件名、目标文件夹、下载进度、创建时间、下载来源链接、下载来源模块、下载回调链接
      1. 目标文件夹需要基于下载来源模块来定位，比如如果是 game.xxx.com.dweb 这样的 jmm 程序，它的文件夹是独立隔离的，所以相对应的，目标文件夹需要基于对应的模块进行翻译，所以这里需要 file.sys.dweb 模块的介入？需要统一出一种文件寻址方式，其背后的基本理念是所有的模块都可能来自网络。
      1. 下载链接来源能确保我们可以回到对应的页面，比如 jmm 模块的下载，能够回到 jmm 的详情页
   1. 下载接口包括：创建、删除、暂停、恢复、取消（释放内句柄）、进度监控
1. ✨ jmm.browser.dweb
   1. ✨ 实现 dweb://jmm-store?source=jmm-store-manifest.json.url 协议，可以将一个网页注册成“JMM 应用源”，就像传统 RSS 订阅源给到用户的概念一样
      1. ✨ 其中 jmm-store-manifest.json 继承于 common-manifest，同时需要补充一些配置：包括 searchUrl、detailUrl
      1. ✨ 用户在使用 web.browser.sys 访问网页的时候，如果打开 dweb://jmm-store?source=url 链接，那么就会提供一个询问跳转的对话框，同意的话就会替代性地使用 jmm.browser.dweb 访问这个网页
   1. ✨ 实现 JmmStore Controller/.Render，用于访问某个应用源，原理和 web.browser.dweb 类似，差别在于会额外提供一些接口，使得网页可以 读取应用列表、读取安装进度、控制安装 等等。
      1. ✨ 其渲染层和 web.browser.dweb 类似，它也可以打开一些特定的网页（如果），这些网页就是“分布式商店”，就像搜索引擎一样。
      1. ✨ 因为这些网页商店没有后端的程序，而鉴于常规 web-api 的标准，我们需要提供一个 navigator.jmmStore 对象，提供 Promise-Like-Api。(注意，这里不需要走 fetch 这样的网络层接口，也不需要提供这样的接口)
   1. ✨ 实现 JmmStoresMananger Controller/.Render，用于 添加、删除、访问 多个应用源
1. 🎉 permission.std.dweb 主要是提供一种注册权限的通用标准，它本身没有任何权限功能，它只负责管理权限。也就是说哪些应用申请权限，都由 permission.sys.dweb 提供询问对话框。这可以避免同时多个权限申请时，对话框可以有序进行调度。
   1. ✨ `[get]/open-native-setting-page` 打开原生的授权设置页面
   1. ✨ dweb+protocol://permission.std.dweb 模块协议，用于注册 ipc 通讯时权限
   1. ✨ permission.std.dweb + permission.sys.dweb 使用 bottom-sheet 来展示权限申请对话框
      ```
         ┌─────────────────────────────────────┐
         │ ┌─────┬──────────────────┬────────┐ │
         │ │icon │ permission text  │ toggle │ │
         │ └─────┴──────────────────┴────────┘ │
         │ ┌─────┬──────────────────┬────────┐ │
         │ │icon │ permission text  │ toggle │ │
         │ └─────┴──────────────────┴────────┘ │
         │ ┌──────┐  ┌───────┐ ┌────────────┐  │
         │ │cancel│  │confirm│ │ GRANT ALL  │  │
         └─┴──────┴──┴───────┴─┴────────────┴──┘
      ```
      1. ✨ 一个应用的多条权限申请使用在一个 bottom-sheet 面板中使用 toggle-button 列出
      1. ✨ 某一条权限的申请都需要用户阅读至少 1.5~3 秒（基于权限的危险性）后才能同意，同时视图使用 LazyColumn，要确保 item 被渲染才算被用户读取。
         1. 如果是传感器的权限，那么通常只需要 1.5s
         1. 如果是涉及到用户的地理坐标、读写相机、读写联系人、读写存储，那么需要 2s 以上
         1. 如果设计到用户的个人数据（这通常是来自其它应用，如短信应用、读取相册）这类数据非常直接，甚至涉及到直接的个人隐私、人格画册，需要慎重考虑的，需要 3s
            > 不过一般情况下，像文件的读取、相册的读取、短信的读取，应用可以通过做 picker，让用户自己选择要被应用读取的内容，从而避免隐私被泄露。
         1. 新的权限申请不能被追加到当前的视图列表中，需要后续再进行组合弹出
      1. 权限模块在使用的时候，需要告知用户应用正在使用的权限功能
   1. ✨ 如果在某个应用在进行权限申请对话框时，有其它应用也在这期间调用了权限申请，那么根据 bottom-sheet 的先进先出原则进行排队，不会有抢占式的问题
1. ✨ key.std.dweb 密钥管理接口
   1. KeyController/.Render，管理面板，提供导入、查看、导出等基本功能
   1. /(create|delete)?for=(\*:reason) 创建密钥，提供某一个原因。会基于 root-key+ipc.mmid+reason 来创建出一个密钥，这个 reason 也是用户在这个密钥时，辅助理解这个密钥的内容
1. 🎉 file.std.dweb
   > 🔊 也许时 cdn 模块的标准？
   >
   > 🔊 是否要增加分组功能？答：不用，专注于自己可读可写就行
   >
   > 这是标准库。要理解 std 和 sys 的主要差异，可以将 sys 理解成直接面向操作系统的 API 进行封装，而 std 属于公共网络服务，任何模块都可以在网络上获取一个存储服务
   1. 🎉 fs-api: open/close/read/write/stat/watch/mkdir/rm/readdir/cp/mv/watchdir/exist
      1. stat 包含 readonly 功能
   1. 🎉 manage-api: env（配置密钥）/quotas（配额量）/eviction（是否持久化）
      > 默认情况下你可以不配置密钥，那么文件服务会给你提供一个临时的隔离的空间，就像内存一样，在断开 ipc 后就释放了
      > 但你可以申请导出一个密钥给你，那么用户只要存好这个密钥，下次再回来导入这个密钥的时候，就能恢复这个数据了
      > 注意，虽然逻辑如此，但这并不能完全确保恢复，因为用户可能自己移除了这些数据，或者硬件损坏，或者服务商切换、等等原因
      > 通常情况下，我们会使用 key.std.dweb 来主动生成密钥，并导入到 file.std.dweb/env 中，等于让 key.std.dweb 来帮助我们存储密钥，这样就不需要每个应用自己去维护密钥
      > 同时利用 key.std.dweb 的密钥导入导出功能，我们就可以实现很自然地读取其它设备的数据
1. ✨ ipc 协议升级（详见[desktop-dev/Readme.md]()）
   1. ✨ 增加握手，使用 UTF8 文本进行握手（这是兼容性最广的标准，因为基本现代化所有编程语言一定会支持 UTF8 字符串）、
      > 需要在握手的过程中解决协议支持的
      > 可以在握手里协商默认的 IpcBody 行为，现在默认是 Paused 状态，可以协商为默认为 Pulled 的状态，这对网络模块这种一定会进行数据转发的会比较友好
   1. ✨ 加入 cbor 的支持，在原生上会有更好的编码性能和效率，在 js 侧可以省去？
   1. ✨ 加入 createChannel 的支持，用于替代大多数场景下使用 ReadableStreamIPC
      1. ✨ ReadableStreamIpc 需要改变格式（现在时 len+body），避免阻塞（改成 channelId+len+body）
   1. ✨ 新增 IpcError，提供原生的错误支持
1. 🎉 模块协议
   > “模块协议”，参考 Obj-C/Swift 里的 Protocol、Golang 里的 Interface，这将是 microModule 支持 POP（面向过程）的重要一环，这里。它基于 deeplink 的协议进行扩展，如上诉格式：它的 hostname 是一个`.dweb`结尾的标准 domain。
   1. 模块新增字段 `protocols: List<Mmid>`，这意味着当前模块可以替代指定的 mmid 来实现对应的功能，从而可以实现模块的替换。理论上这种替换对 `dns.std.dweb` 模块也是有效的
      > 这是否会存在被人恶意利用不好说，但 dweb 的标准中不会明确说明有什么限制，所有各个平台可以自己做一些实现，如果顾及到安全性，在某些平台上，可以选择性忽视某些安全性模块或者强制性模块，这完全取决于平台
      > 在 dweb-browser 这个平台中，我们尽可能探索一种在可视化可控制的环境下，给用户完全的自主选择的权利，因此我们暂时不对此做出任何限制，但是会从底层引擎那里告知用户发生了什么事情。
      > 这需要我们提供一个依赖图谱、互联图谱 来告知用户所有模块的状况，有必要的情况下，用户可以随时掐断这个图谱中的某一个节点，将它冻结，因此对于开启启动项，我们目前需要谨慎给出“记忆功能”，这可以确保用户可以通过重启来恢复整个系统。
   1. dns 模块需要提供一个选择器，当某个模块可以被其它模块替代的时候，提供选择器
   1. dns 需要记忆该选择，有几种记忆模式：
      1. 保持不变（如果有之前的记忆）
      1. 允许一次
      1. 该选择只对当前应用有效
      1. 该选择为全部应用有效
   1. 当模块升级，或者有新的可替换模块出现的时候，选择器需要重新弹出，无关的模块减少不需要重新弹出选择器
   1. 未来 dns 需要为这个选择器提供管理器，也就是“依赖图谱”
1. 🎉 id-card.std.dweb
   1. 这只是一个存储器，但是是专门用户存储个人网络信息
   1. 可以存储多个身份，这里的身份就是一个卡片
      1. 卡片本质就是一个 key-value 存储器
      1. 对于 key：软件也会内置一些常见的字段名称：“名字”、“出生日期” 等，但这不是强制的，只是一个推荐性的文本，这种推荐文本会有多语言的功能
      1. 用户可以自己设计卡片字段，除了常见的文本类型：文本、数字、时间、邮箱、号码、账号 ID、密码 等，还会有功能性类型：“密钥”
      1. 密钥一般会有两种
         1. 一种是身份验证器，这一般是服务端生成密钥给用户，就是服务端与客户端使用统一的算法，每隔一分钟会生成一段数字作为密码，这种一般是服务端提供密钥
         1. 一种是签名密钥，这一般用户生成密钥然后将公钥给服务端，服务端每次需要认证时，提供一串有意义的文本给客户端，让客户端为它签名，用户通常需要仔细阅读这个文本
      1. 在使用的卡片的时候，调用者需要提供需要输入的字段以及类型，那么会自动尝试关联，否则需要用户通过拖拽来将卡片中的信息拖入，这种拖拽会形成一种关联性，基于这种关联性，可以进行机器学习，从而形成自动填充的命中率
      1. 密钥类型是被禁止直接填入的，所以作为功能性字段，它只能提供签名、提供口令等功能
         > 如果有输入密钥的功能，请使用“密码”类型进行存储，这需要使用者务必小心，因为通常不会有这种需求，有这种需求通常是流氓软件
   1. 对于一张卡片中需要加密的部分，用户可以勾选那些敏感信息的字段，并为其赋予查阅密码
   1. 为了对抗网络画像，我们会推荐用户使用多个身份来做不同的事情，这也是这个身份存储器能过提供的功能
      1. 比方说，在你购买生活用品时，我们使用身份 A，在你购买电子产品时，使用身份 B，使用不同的身份从而隔绝用户画像的生成问题，这样可以友好地保护用户隐私
         > 但免不了有些霸王条款会强制用户的物理身份证认证信息，这时候也没有办法，毕竟物理身份证信息的一般是需要进行三方认证的，这时候用户画像跟你的手机号码背后的身份证号码进行强关联，从而无法避免。
         > 但是随着分布式网络的构成，这种理念在 dweb-browser 中会变成有专门的人代理做中间商，就会你可以借用别人的用户画像购买特定的商品，配合使用数字人民币这类大型私有链，从而避免商家的隐私窃取。
         > 至于是否使用这种方式去进行一些非法工作，这属于数字人民币的工作职能，它能大数据分析其中的资金流动，从而打击犯罪。另外，也需要用户自觉，尽可能购买使用全链路受法律管辖支付的商品。
      1. 当调用者尝试来读取用户的信息时，我们可以根据应用的“分类”，为其提供推荐的身份，或者用户可以快速在第一身份（默认身份证）的基础上创建出一个新的身份
   1. 要实现“全链路监管”，需要有一个“身份证书”来解决认证问题。
      > 全链路监管在有些地区是必要的，这是个人与社会的关系中需要去遵循的平衡，毕竟和平不是免费的午餐，需要一个区域中的所有人都遵循某种协议才能达成。
      > 因此证书的作用，是用来证明身份的合法性，比方说店铺需要有营业资质，个人也需要有身份信息。
      > 基于这个证书，我们可以实现类似于“身份验证器”的功能，并给予此功能实现隐私保护，比方说 A 向 B 购买商品，那么 A 与 B 需要使用证书来生成一个“临时身份”，这个临时身份是可以被验证“资质合法性”，那么 A 与 B 都可以对于资格进行验证，这时候就不是面相身份了，因此也就能避免信息收集的问题。
1. 🎉 tunnel.dweb-browser.com.dweb
   1. 🎉 `dweb+protocol://tunnel.http.std.dweb`
      > 负责提供 HTTP 网络隧道网络模块，可以将自己的网络暴露到公网中
      1. ✨ `/registry?subDomain=*&publicKey=*&ttl=*` 提供一个公钥，并用此注册一个域名，并且需要提供一个域名存活时间
         1. subDomain 只能是一个单词`[a-zA-Z0-9]`，不可出现`./-`这类特殊字符，如果出现了预期之外的单词，那么服务器有权拒绝注册，或者会自动给出一个尽可能保留合法内容的词汇，比如说：`abc@efg`可能会变成`abc0efg19`
         1. ttl 意味着域名存活时间，意味假设服务器与注册者断开连接后，服务器会为注册者保留多少的。如果在付费服务器上，这项服务可能会根据存活时间来进行收费
         1. 如果有需要，带上受到支持的加密算法名称 `&algorithm=*`，取决于服务端支持的算法范围
         1. 如果有需要，带上受到授权签名 `&auth=*`，这是对某一段信息进行加密，加密者为 subDomain 的上级所有者，所以首先要服务端实现多级管理的功能
            1. 如果需要路由的负载均衡，那么 auth 中需要携带的信息是：`{ toPublicKey:String, matchs:URLPattern }`
            1. 如果需要域名的多级分发，那么 auth 中需要携带的信息是：`{ toPublicKey:String, subDomain: String }`，其中 subDomain 可以是 `a.b`/`*.b`/`**.b`
         1. 200 返回注册成功后公有域名
         1. 401 认证错误，可能是域名所有权被占用
      1. ✨ 在 tunnel.dweb-browser.com.dweb 应用中，它还会读取本地 http 服务器的统一端口，并将这个端口转发到服务端
         1. ✨ `[get]file://http.sys.dweb/gateway-port` 读取当前 http 服务所监听到网关端口
         1. ✨ 应用需要提供一个“一键启动”的管理界面，第一次启动这个 jmm 应用后，需要用户同意才会启动这个隧道服务，这时应用需要用户输入它的用户名，或者唤醒 id-card.std.dweb 来获取
   1. 🎉 `dweb+protocol://search.std.dweb`
      > 提供搜索协议的实现，jmm 与 tunnel 理论上可以提供这个搜索服务，那么我们就可以知道要安装本地模块，或者是可以链接到某个域名
      1. ✨ `/query?s=*` 返回这个标准定义好的类型，比如：`{type:'link',data:''}`
1. 🎉 geolocation.sys.dweb 地理位置模块
   1. ✨ `[get]/position?精度=*` 检索设备的当前位置，返回类型为[GeolocationPosition](https://developer.mozilla.org/zh-CN/docs/Web/API/GeolocationPosition)
   1. ✨ `[duplex]/position?fps=*&精度=*` 注册一个处理函数，实时收集设备的位置信息（按需触发）。
1. 🎉 `dweb+protocol://splashscreen.window.std.dweb/`
   > ✨ 这是一个渲染器，一般用于提供启动屏的渲染功能，它提供了类似 css-background-image 的声明式渲染，并且接口的设计上也进行了一定的借鉴
   > 参考资料 [Web-CSS-Background](https://developer.mozilla.org/en-US/docs/Web/CSS/background)
   1. `/render?query=*&color=*&image=*&position=*&size=*`
      > 🔊 增加 MicroModuleManifest.mainWindow 字段，可以配置应用启动的时候默认视图的 URI，从而可以将视图委托给第三方模块来渲染，为此可以可以实现将快速将一个 Web 打包成一个 App 的功能
      1. CSS-Background 中，它可以提供多个 background（使用`,`分隔），正常情况下，这些 background 是叠加在一起的
      1. 这里额外提供了一个 query 字段，参考 container-query，同样我们也使用`,`分割，并将匹配的 background 进行显示，如果不提供默认为匹配成功
      1. 🔊 我们是否要直接使用 js-disabled 的 webview 进行渲染（我们自己进行 html+css 的翻译），还是用原生实现只提供一个子集？
1. 🐛 下载切换到 ktor 之后下载失败很常见，点击下载会出现重新下载问题
1. 🐛 desktop-dev dweb://deeplinks 功能还未实现
1. 🐛 maxTarget 需要下取整？
   > 因为 target 可能出现 2.1、2.2、2.3 这样的功能性布丁，这都是与 2 兼容的。
   > 这时候 maxTarget 如果写了 2，那么往往就意味着 2.? 其实都是可以的。
   > 因此 minTarget 可能写的是 2.2，maxTarget 写的可能是 2，出现 minTarget 大于 maxTarget 的情况，这会令人疑惑
   > 所以可以考虑这两种写法：
   1. `<3` 提供版本运算符？但是看着很奇怪，而且增加了学习成本，不建议
   1. `2.*` 提供简单的通配符，这个灵活性很多，可能过大了？但个人更加建议这个方案
1. 🐛 webview 在 loadUrl 失败的时候，没有正确地处理请求。
1. 🎉 media-capture.sys.dweb 媒体捕获器
   1. `/capture?mime=*` 提供相应的系统选择器，目前支持：音频、视频、照片 三种媒体捕捉
1. 🎉 contact-picker.sys.dweb 联系人选择器
1. 🎉 file-picker.sys.dweb 文件选择器
1. 🎉 motion-sensors.sys.dweb 运动传感器
   1. `[duplex]/XYZ加速度`
   1. `[duplex]/capture?action=摇一摇|跌倒` 动作捕捉
1. 🎉 shortcut.sys.dweb
   1. ✨ ShortcutManagerController/.Render 排序、管理要显示在原生上的项目
   1. ✨ `/registry?title=*&uri=*&icon?=*&persistence?=*` 提供功能注册，我们需要根据对方的 mmid 来进行保存
      1. icon: 使用对方的 app-icon 做为默认图标，如果对方自己提供了 shortcut-icon，那么将 app-icon 做为 shortcut-icon 的角标
      1. persistence: 是否进行持久化，默认是。如果非持久化，那么在 ipc 断开连接时，这个 shortcut 会被释放。
   1. ✨ 每次启动的时候，都要便利 shortcut 的生命周期，比如查询应用是否被卸载、是否是非持久化快捷，从而移除相应的图标注册（可以考虑移动到 tmp 文件夹中，如果应用恢复，那么可以找回；否则空间回收时被清理）
   1. ✨ 监听 dns 安装到应用的变更
   1. 🔊 如何实现声明式的快捷？

# Plaoc

1. 🎉 实现将一个网页直接打包成应用，它的重点在于一些路由的转发、deeplink 的适配

# Android

1. ♻️ web.browser.dweb
   1. ♻️ 优化扫码模块，使用 barcode-scanning.sys.dweb
1. 🐛 file.sys.dweb 修复存储照片而在系统相册没显示问题

# IOS

1. 迁移 C# 版的 DwebView，与 Android 版本共同构建出 common-DwebView
2. 打通 UIViewController 与 Compose-kotlin-native 的互操作性
3. keyboard、navbar、statubar 这些 systembar 在 WindowManagerRender 下的兼容性
4. sys 插件迁移

# Desktop

1. 实现 common-DwebView 的 js 版
1. 打通 Electron-Webview 与 Compose-kotlin-js 的互操作性
1. sys 插件迁移

# Network

1. 实现聊天应用中：
   - 对点通讯
   - 群组通讯
   - 离线消息
   - 用户查找
   - 陌生人留言（每 3 个月内只能留言一条，直到对方回复了才能进行正常对话，加成好友才能允许“卡片分享”的功能）
1. 分布式搜索协议（至少要设计出来）
1. 分布式协同数据同步，确保聊天应用可以跨网络节点进行使用（至少要设计出来）
1. ? 🎉 pubsub.std.dweb
   1. create
   1. join
   1. pub
   1. sub
   1. redis?
1. 代理服务：服务端配额+客户端模式

# Other

1.

# 讨论

1. 灵动岛的 API 可以用来实现 toast.sys.dweb？
1. 安装桌面端模拟器（https://mumu.163.com/update/）测试兼容问题
1. jmm-store-manifest.json 中是否要实现 pushWsUrl，这可以让商店开发者提供一个链接，用来推送的信息，包括应用升级、推广信息等。
1. 将https://wasmedge.org/嵌入到DwebBrowser中？它可以提供nodejs运行时，这个工作量不小，而它是可以开箱即用。我们需要做的可能在就是在它内建的fetch函数的基础上加入ipc的支持？
1. 提供 区域特供版版 和 国际版？
   > 国内版只是内置安装了一些政府级别或者民生级别的应用，主体部分和国际版一样，也就是说国际版也可以无差别安装这些应用
   > 这样做的效果是可以减少国内用户的使用门槛，对于专业用户，想要自己定制的，可以使用国际版，也就是纯净版。
   > 国内版因为可以内嵌应用，所以可以作为盈利的一个点来使用，以下是一些值得添加的模块
   1. 网络服务模块，这个模块的作用是与 golang 的网关服务做 ipc 连接，然后将收到的请求在本地 http 模块的端口上重放请求
   1. jmm 内置商店源
      1. [awesome-bfmeta/dweb-apps](https://github.com/BFChainMeta/awesome-bfmeta/tree/main/src/dweb-app-assets)
      1. 我们团队自己开发一些自己用得上的生活类工具、或者是打包一些第三方站点、或者打包一些开源的
   1. 我们要实现一个自动化程序（setup.browser.dweb）来实现这些功能，将这些内置模块在启动的时候，在授权协议中，提供默认的选项，如果同意对应的协议，那么就可以进行默认安装。因为它是一个 Application 模块，所以错过的用户也可以点击桌面上的图标，使用它再进行安装
      1. 它要能沉默地安装其它模块，这种特例是否是好的？
      1. 要能添加 jmm 源
      1. 要能添加 web.browser.dweb 的桌面快捷链接

# 未来

1. Dweb-OS
1. 协同办公（我们自己用）
1. 知识版权保护（自签、自主分发、保护小企业创作避免被大企业抄袭）
1. Notification-Management
1. 原生桌面小组件
